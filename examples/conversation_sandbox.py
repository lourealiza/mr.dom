#!/usr/bin/env python3
"""
Sandbox de Conversa - MrDom SDR AgentOS + Bedrock
Interface interativa para testar agentes antes de integrar com N8N.
"""

import os
import asyncio
import json
from typing import Dict, Any, List
from datetime import datetime
import sys
from pathlib import Path

# Adiciona path da API
api_path = Path(__file__).parent.parent / "api"
sys.path.insert(0, str(api_path))

class ConversationSandbox:
    """Sandbox interativo para testar conversas com agentes."""
    
    def __init__(self):
        self.conversation_history = []
        self.agents = {
            "lead-qualifier": {
                "name": "Lead Qualifier",
                "description": "Especialista em qualifica√ß√£o BANT",
                "system_prompt": """Voc√™ √© um especialista em qualifica√ß√£o de leads BANT 
                (Budget, Authority, Need, Timeline). Sua fun√ß√£o √© fazer perguntas inteligentes 
                para determinar se um lead √© qualificado para uma proposta comercial.
                
                Pergunte sobre:
                - Budget: Qual o investimento dispon√≠vel?
                - Authority: Voc√™ tem poder de decis√£o?
                - Need: Qual o problema principal?
                - Timeline: Quando precisa resolver?"""
            },
            "sales-sdr": {
                "name": "Sales SDR",
                "description": "Especialista em agendamento de demos",
                "system_prompt": """Voc√™ √© um SDR experiente focado em gerar interesse 
                e agendar reuni√µes de vendas. Use t√©cnicas de vendas consultivas para 
                identificar necessidades e criar urg√™ncia.
                
                Foque em:
                - Identificar necessidades espec√≠ficas
                - Criar urg√™ncia para agendamento
                - Oferecer valor na demo
                - Confirmar dados para contato"""
            },
            "customer-success": {
                "name": "Customer Success",
                "description": "Especialista em suporte e sucesso",
                "system_prompt": """Voc√™ √© especialista em sucesso do cliente, focado em 
                resolver problemas, aumentar satisfa√ß√£o e identificar oportunidades de 
                upselling.
                
                Priorize:
                - Resolver problemas rapidamente
                - Explicar solu√ß√µes claramente
                - Identificar oportunidades de melhoria
                - Escalar quando necess√°rio"""
            }
        }
        
        # Simula dados de contexto do CRM
        self.mock_context = {
            "conversation_id": "sandbox_123",
            "account_id": "1",
            "lead_exists": False,
            "phone": "+5511998765432",
            "nome": "Jo√£o Silva",
            "email": "joao@empresa.com",
            "empresa": "Empresa ABC",
            "origem": "MrDOM Sandbox"
        }
    
    def print_header(self):
        """Imprime cabe√ßalho do sandbox."""
        print("ü§ñ SANDBOX DE CONVERSA - MrDom SDR AgentOS + Bedrock")
        print("=" * 60)
        print("üìã Agentes dispon√≠veis:")
        for agent_id, agent in self.agents.items():
            print(f"   {agent_id}: {agent['name']} - {agent['description']}")
        print("\nüí° Comandos especiais:")
        print("   /help - Mostra ajuda")
        print("   /agents - Lista agentes")
        print("   /context - Mostra contexto atual")
        print("   /history - Mostra hist√≥rico")
        print("   /clear - Limpa hist√≥rico")
        print("   /switch <agent> - Troca agente")
        print("   /quit - Sair")
        print("=" * 60)
    
    def print_context(self):
        """Mostra contexto atual."""
        print("\nüìä CONTEXTO ATUAL:")
        print("-" * 30)
        for key, value in self.mock_context.items():
            print(f"   {key}: {value}")
    
    def print_history(self):
        """Mostra hist√≥rico da conversa."""
        print("\nüìú HIST√ìRICO DA CONVERSA:")
        print("-" * 40)
        
        if not self.conversation_history:
            print("   Nenhuma mensagem ainda.")
            return
        
        for i, entry in enumerate(self.conversation_history, 1):
            timestamp = entry.get('timestamp', 'N/A')
            agent = entry.get('agent', 'N/A')
            user_msg = entry.get('user_message', '')
            agent_response = entry.get('agent_response', '')
            
            print(f"\n   {i}. [{timestamp}] Agente: {agent}")
            print(f"      üë§ Usu√°rio: {user_msg}")
            print(f"      ü§ñ Agente: {agent_response[:100]}{'...' if len(agent_response) > 100 else ''}")
    
    def clear_history(self):
        """Limpa hist√≥rico da conversa."""
        self.conversation_history = []
        print("‚úÖ Hist√≥rico limpo!")
    
    def switch_agent(self, agent_id: str):
        """Troca agente atual."""
        if agent_id in self.agents:
            self.current_agent = agent_id
            print(f"‚úÖ Agente trocado para: {self.agents[agent_id]['name']}")
        else:
            print(f"‚ùå Agente '{agent_id}' n√£o encontrado.")
            print("Agentes dispon√≠veis:", list(self.agents.keys()))
    
    def suggest_agent(self, message: str) -> str:
        """Sugere melhor agente baseado na mensagem."""
        message_lower = message.lower()
        
        if any(word in message_lower for word in ["pre√ßo", "custo", "or√ßamento", "investimento", "quanto"]):
            return "lead-qualifier"
        elif any(word in message_lower for word in ["demo", "reuni√£o", "agendar", "apresenta√ß√£o", "meeting"]):
            return "sales-sdr"
        elif any(word in message_lower for word in ["problema", "bug", "erro", "suporte", "ajuda", "n√£o funciona"]):
            return "customer-success"
        else:
            return "lead-qualifier"  # default
    
    async def simulate_agent_response(self, agent_id: str, message: str, context: Dict) -> str:
        """Simula resposta do agente (sem AgentOS real)."""
        agent = self.agents[agent_id]
        
        # Simula diferentes tipos de resposta baseado no agente
        if agent_id == "lead-qualifier":
            if "pre√ßo" in message.lower():
                return "Entendo que voc√™ quer saber sobre investimento. Para te dar uma proposta adequada, preciso entender melhor: qual o tamanho da sua empresa e quantas pessoas trabalham no time de vendas?"
            elif "empresa" in message.lower():
                return "√ìtimo! E quantas pessoas trabalham no seu time de vendas hoje? Isso me ajuda a entender melhor o cen√°rio."
            else:
                return "Ol√°! Sou especialista em qualifica√ß√£o de leads. Para te ajudar melhor, me conte: qual √© o principal desafio que voc√™s enfrentam nas vendas hoje?"
        
        elif agent_id == "sales-sdr":
            if "demo" in message.lower() or "reuni√£o" in message.lower():
                return "Perfeito! Tenho 2 hor√°rios dispon√≠veis esta semana: ter√ßa √†s 14h ou quinta √†s 10h. Qual funciona melhor para voc√™? Vou precisar do seu email para enviar o link da reuni√£o."
            else:
                return "Entendo seu interesse! Uma demo de 30 minutos seria ideal para mostrar como podemos resolver seus desafios. Voc√™ tem disponibilidade esta semana?"
        
        elif agent_id == "customer-success":
            if "problema" in message.lower():
                return "Entendo que voc√™ est√° enfrentando dificuldades. Vou te ajudar a resolver isso rapidamente. Pode me dar mais detalhes sobre o que est√° acontecendo?"
            else:
                return "Ol√°! Estou aqui para te ajudar com qualquer quest√£o. Como posso te auxiliar hoje?"
        
        return "Obrigado pela sua mensagem! Como posso te ajudar?"
    
    async def process_message(self, message: str, agent_id: str = None) -> Dict[str, Any]:
        """Processa mensagem com agente espec√≠fico."""
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        # Escolhe agente se n√£o especificado
        if not agent_id:
            agent_id = self.suggest_agent(message)
        
        # Simula resposta do agente
        agent_response = await self.simulate_agent_response(agent_id, message, self.mock_context)
        
        # Salva no hist√≥rico
        entry = {
            "timestamp": timestamp,
            "agent": self.agents[agent_id]["name"],
            "agent_id": agent_id,
            "user_message": message,
            "agent_response": agent_response,
            "context": self.mock_context.copy()
        }
        
        self.conversation_history.append(entry)
        
        return {
            "success": True,
            "agent_id": agent_id,
            "agent_name": self.agents[agent_id]["name"],
            "response": agent_response,
            "timestamp": timestamp
        }
    
    def handle_command(self, command: str) -> bool:
        """Processa comandos especiais. Retorna True se deve continuar."""
        cmd = command.strip().lower()
        
        if cmd == "/help":
            self.print_header()
        elif cmd == "/agents":
            print("\nü§ñ AGENTES DISPON√çVEIS:")
            for agent_id, agent in self.agents.items():
                print(f"   {agent_id}: {agent['name']}")
                print(f"      {agent['description']}")
        elif cmd == "/context":
            self.print_context()
        elif cmd == "/history":
            self.print_history()
        elif cmd == "/clear":
            self.clear_history()
        elif cmd.startswith("/switch "):
            agent_id = cmd.split(" ", 1)[1]
            self.switch_agent(agent_id)
        elif cmd == "/quit":
            print("üëã Saindo do sandbox...")
            return False
        else:
            print(f"‚ùå Comando desconhecido: {command}")
            print("Use /help para ver comandos dispon√≠veis.")
        
        return True
    
    async def run(self):
        """Executa o sandbox interativo."""
        self.print_header()
        
        # Agente inicial
        self.current_agent = "lead-qualifier"
        print(f"\nüéØ Agente inicial: {self.agents[self.current_agent]['name']}")
        print("üí¨ Digite sua mensagem ou comando:")
        
        while True:
            try:
                # L√™ entrada do usu√°rio
                user_input = input("\nüë§ Voc√™: ").strip()
                
                if not user_input:
                    continue
                
                # Verifica se √© comando
                if user_input.startswith("/"):
                    if not self.handle_command(user_input):
                        break
                    continue
                
                # Processa mensagem
                print("ü§ñ Processando...")
                result = await self.process_message(user_input, self.current_agent)
                
                if result["success"]:
                    print(f"\nü§ñ {result['agent_name']}: {result['response']}")
                    
                    # Sugere pr√≥ximo agente se necess√°rio
                    suggested = self.suggest_agent(user_input)
                    if suggested != self.current_agent:
                        print(f"\nüí° Sugest√£o: Use '/switch {suggested}' para trocar para {self.agents[suggested]['name']}")
                else:
                    print(f"‚ùå Erro: {result.get('error', 'Desconhecido')}")
                
            except KeyboardInterrupt:
                print("\n\nüëã Saindo do sandbox...")
                break
            except Exception as e:
                print(f"‚ùå Erro: {str(e)}")
        
        # Mostra resumo final
        print(f"\nüìä RESUMO DA SESS√ÉO:")
        print(f"   Mensagens trocadas: {len(self.conversation_history)}")
        print(f"   Agentes usados: {set(entry['agent_id'] for entry in self.conversation_history)}")

def check_environment():
    """Verifica configura√ß√£o do ambiente."""
    print("üîß Verificando configura√ß√£o...")
    
    # Verifica AWS credentials
    aws_key = os.getenv("AWS_ACCESS_KEY_ID")
    aws_secret = os.getenv("AWS_SECRET_ACCESS_KEY")
    
    if aws_key and aws_secret:
        print("‚úÖ AWS Bedrock configurado")
    else:
        print("‚ö†Ô∏è AWS credentials n√£o configuradas")
        print("   Executando em modo simula√ß√£o")
    
    # Verifica AgentOS
    try:
        import agno
        print("‚úÖ AgentOS dispon√≠vel")
    except ImportError:
        print("‚ö†Ô∏è AgentOS n√£o dispon√≠vel - usando simula√ß√£o")
    
    return True

async def main():
    """Fun√ß√£o principal."""
    print("üöÄ Iniciando Sandbox de Conversa...")
    
    # Verifica ambiente
    check_environment()
    
    # Cria e executa sandbox
    sandbox = ConversationSandbox()
    await sandbox.run()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nüëã Sandbox interrompido pelo usu√°rio")
    except Exception as e:
        print(f"\n‚ùå Erro inesperado: {str(e)}")
