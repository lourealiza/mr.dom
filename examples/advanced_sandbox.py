#!/usr/bin/env python3
"""
Sandbox Avan√ßado - Conecta com API AgentOS real quando dispon√≠vel.
"""

import os
import asyncio
import json
import requests
from typing import Dict, Any, Optional
from datetime import datetime
import sys
from pathlib import Path

# Adiciona path da API
api_path = Path(__file__).parent.parent / "api"
sys.path.insert(0, str(api_path))

class AdvancedSandbox:
    """Sandbox que se conecta com API AgentOS real."""
    
    def __init__(self):
        self.api_url = "http://localhost:8000"
        self.conversation_history = []
        self.mock_context = {
            "conversation_id": "sandbox_123",
            "account_id": "1",
            "lead_exists": False,
            "phone": "+5511998765432",
            "nome": "Jo√£o Silva",
            "email": "joao@empresa.com",
            "empresa": "Empresa ABC",
            "origem": "MrDOM Sandbox"
        }
        
        # Verifica se API est√° dispon√≠vel
        self.api_available = self.check_api_availability()
        
        if self.api_available:
            print("‚úÖ Conectado √† API AgentOS")
        else:
            print("‚ö†Ô∏è API n√£o dispon√≠vel - usando simula√ß√£o")
    
    def check_api_availability(self) -> bool:
        """Verifica se a API AgentOS est√° dispon√≠vel."""
        try:
            response = requests.get(f"{self.api_url}/api/v1/agents/status", timeout=5)
            return response.status_code == 200
        except:
            return False
    
    async def get_agent_suggestion(self, message: str) -> str:
        """Obt√©m sugest√£o de agente da API."""
        if not self.api_available:
            return self.suggest_agent_local(message)
        
        try:
            response = requests.post(
                f"{self.api_url}/api/v1/agents/suggest",
                json={"message": message},
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                return data.get("suggested_agents", ["lead-qualifier"])[0]
            else:
                return self.suggest_agent_local(message)
                
        except:
            return self.suggest_agent_local(message)
    
    def suggest_agent_local(self, message: str) -> str:
        """Sugest√£o local de agente."""
        message_lower = message.lower()
        
        if any(word in message_lower for word in ["pre√ßo", "custo", "or√ßamento"]):
            return "lead-qualifier"
        elif any(word in message_lower for word in ["demo", "reuni√£o", "agendar"]):
            return "sales-sdr"
        elif any(word in message_lower for word in ["problema", "bug", "suporte"]):
            return "customer-success"
        else:
            return "lead-qualifier"
    
    async def process_with_api(self, message: str, agent_id: str = None) -> Dict[str, Any]:
        """Processa mensagem usando API AgentOS."""
        try:
            if agent_id:
                # Usa agente espec√≠fico
                response = requests.post(
                    f"{self.api_url}/api/v1/agents/process",
                    json={
                        "agent_id": agent_id,
                        "message": message,
                        "context": self.mock_context
                    },
                    timeout=30
                )
            else:
                # Usa melhor agente automaticamente
                response = requests.post(
                    f"{self.api_url}/api/v1/agents/process-best",
                    json={
                        "message": message,
                        "context": self.mock_context
                    },
                    timeout=30
                )
            
            if response.status_code == 200:
                data = response.json()
                return {
                    "success": True,
                    "agent_id": data.get("selected_agent", agent_id),
                    "response": data.get("result", {}).get("response", ""),
                    "api_used": True
                }
            else:
                return {
                    "success": False,
                    "error": f"API error: {response.status_code}",
                    "api_used": True
                }
                
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "api_used": True
            }
    
    async def process_with_simulation(self, message: str, agent_id: str = None) -> Dict[str, Any]:
        """Processa mensagem usando simula√ß√£o local."""
        if not agent_id:
            agent_id = await self.get_agent_suggestion(message)
        
        # Simula resposta baseada no agente
        if agent_id == "lead-qualifier":
            if "pre√ßo" in message.lower():
                response = "Entendo que voc√™ quer saber sobre investimento. Para te dar uma proposta adequada, preciso entender melhor: qual o tamanho da sua empresa e quantas pessoas trabalham no time de vendas?"
            else:
                response = "Ol√°! Sou especialista em qualifica√ß√£o de leads. Para te ajudar melhor, me conte: qual √© o principal desafio que voc√™s enfrentam nas vendas hoje?"
        
        elif agent_id == "sales-sdr":
            if "demo" in message.lower():
                response = "Perfeito! Tenho 2 hor√°rios dispon√≠veis esta semana: ter√ßa √†s 14h ou quinta √†s 10h. Qual funciona melhor para voc√™?"
            else:
                response = "Entendo seu interesse! Uma demo de 30 minutos seria ideal para mostrar como podemos resolver seus desafios. Voc√™ tem disponibilidade esta semana?"
        
        elif agent_id == "customer-success":
            response = "Entendo que voc√™ est√° enfrentando dificuldades. Vou te ajudar a resolver isso rapidamente. Pode me dar mais detalhes sobre o que est√° acontecendo?"
        
        else:
            response = "Obrigado pela sua mensagem! Como posso te ajudar?"
        
        return {
            "success": True,
            "agent_id": agent_id,
            "response": response,
            "api_used": False
        }
    
    async def process_message(self, message: str, agent_id: str = None) -> Dict[str, Any]:
        """Processa mensagem (API ou simula√ß√£o)."""
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        # Tenta usar API primeiro
        if self.api_available:
            result = await self.process_with_api(message, agent_id)
        else:
            result = await self.process_with_simulation(message, agent_id)
        
        # Adiciona timestamp
        result["timestamp"] = timestamp
        result["user_message"] = message
        
        # Salva no hist√≥rico
        self.conversation_history.append(result)
        
        return result
    
    def print_status(self):
        """Mostra status da conex√£o."""
        print(f"\nüìä STATUS DO SANDBOX:")
        print(f"   API AgentOS: {'‚úÖ Conectada' if self.api_available else '‚ùå Indispon√≠vel'}")
        print(f"   URL: {self.api_url}")
        print(f"   Modo: {'API Real' if self.api_available else 'Simula√ß√£o'}")
        print(f"   Mensagens: {len(self.conversation_history)}")
    
    def export_conversation(self, filename: str = None):
        """Exporta conversa para arquivo JSON."""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"conversation_export_{timestamp}.json"
        
        export_data = {
            "timestamp": datetime.now().isoformat(),
            "api_used": self.api_available,
            "conversation": self.conversation_history,
            "context": self.mock_context
        }
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(export_data, f, indent=2, ensure_ascii=False)
        
        print(f"‚úÖ Conversa exportada para: {filename}")
    
    async def run(self):
        """Executa o sandbox avan√ßado."""
        print("ü§ñ SANDBOX AVAN√áADO - MrDom SDR AgentOS")
        print("=" * 50)
        
        self.print_status()
        
        print("\nüí° Comandos dispon√≠veis:")
        print("   /status - Mostra status da conex√£o")
        print("   /export - Exporta conversa para JSON")
        print("   /history - Mostra hist√≥rico")
        print("   /clear - Limpa hist√≥rico")
        print("   /quit - Sair")
        print("\nüí¨ Digite sua mensagem:")
        
        while True:
            try:
                user_input = input("\nüë§ Voc√™: ").strip()
                
                if not user_input:
                    continue
                
                # Comandos especiais
                if user_input == "/status":
                    self.print_status()
                    continue
                elif user_input == "/export":
                    self.export_conversation()
                    continue
                elif user_input == "/history":
                    print(f"\nüìú Hist√≥rico ({len(self.conversation_history)} mensagens):")
                    for i, entry in enumerate(self.conversation_history, 1):
                        print(f"   {i}. [{entry['timestamp']}] {entry['user_message'][:50]}...")
                    continue
                elif user_input == "/clear":
                    self.conversation_history = []
                    print("‚úÖ Hist√≥rico limpo!")
                    continue
                elif user_input == "/quit":
                    break
                
                # Processa mensagem
                print("ü§ñ Processando...")
                result = await self.process_message(user_input)
                
                if result["success"]:
                    mode = "API" if result.get("api_used") else "Simula√ß√£o"
                    agent = result.get("agent_id", "unknown")
                    response = result.get("response", "")
                    
                    print(f"\nü§ñ [{mode}] {agent}: {response}")
                else:
                    print(f"‚ùå Erro: {result.get('error', 'Desconhecido')}")
                
            except KeyboardInterrupt:
                print("\n\nüëã Saindo do sandbox...")
                break
            except Exception as e:
                print(f"‚ùå Erro: {str(e)}")
        
        # Resumo final
        print(f"\nüìä RESUMO DA SESS√ÉO:")
        print(f"   Mensagens: {len(self.conversation_history)}")
        print(f"   Modo: {'API Real' if self.api_available else 'Simula√ß√£o'}")
        
        if self.conversation_history:
            agents_used = set(entry.get('agent_id', 'unknown') for entry in self.conversation_history)
            print(f"   Agentes usados: {', '.join(agents_used)}")

async def main():
    """Fun√ß√£o principal."""
    print("üöÄ Iniciando Sandbox Avan√ßado...")
    
    sandbox = AdvancedSandbox()
    await sandbox.run()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nüëã Sandbox interrompido pelo usu√°rio")
    except Exception as e:
        print(f"\n‚ùå Erro inesperado: {str(e)}")
